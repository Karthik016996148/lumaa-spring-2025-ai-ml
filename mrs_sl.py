# -*- coding: utf-8 -*-
"""MRS_SL.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tUZndNHY7QeX_LHMJj-55qJ5aGcW_XxN
"""

import streamlit as st
import pandas as pd
import re
import string
import nltk

# Download stopwords before importing them
nltk.download('stopwords', quiet=True)
from nltk.corpus import stopwords

from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

def preprocess_text(text):
    """Convert text to lowercase, remove punctuation, and filter out stopwords."""
    text = text.lower()
    text = re.sub(f"[{string.punctuation}]", "", text)
    words = text.split()
    words = [word for word in words if word not in stopwords.words('english')]
    return " ".join(words)

@st.cache_data
def load_data():
    """Load and preprocess the dataset."""
    file_path = "imdb_1000_movies.csv"
    df = pd.read_csv(file_path)

    # Rename columns for clarity
    df.columns = [
        "ranking", "movie_name", "year", "certificate", "runtime", "genre",
        "rating", "metascore", "movie_detail", "director", "actor_1",
        "actor_2", "actor_3", "actor_4", "votes", "gross_collection"
    ]

    # Select only required columns and drop missing values
    df = df[["movie_name", "movie_detail"]].dropna().reset_index(drop=True)

    # Preprocess the movie details
    df["processed_detail"] = df["movie_detail"].apply(preprocess_text)
    return df

@st.cache_resource
def get_tfidf_resources(df):
    """
    Initialize the TF-IDF vectorizer and transform the processed movie details.
    Returns both the vectorizer and the TF-IDF matrix.
    """
    tfidf_vectorizer = TfidfVectorizer()
    tfidf_matrix = tfidf_vectorizer.fit_transform(df["processed_detail"])
    return tfidf_vectorizer, tfidf_matrix

def recommend_movies(user_query, tfidf_vectorizer, tfidf_matrix, df, top_n=5):
    """
    Process the user's query, compute cosine similarity with movie details,
    and return the top N movie recommendations.
    """
    # Preprocess the user's query
    processed_query = preprocess_text(user_query)

    # Convert the processed query into a TF-IDF vector
    query_vector = tfidf_vectorizer.transform([processed_query])

    # Compute cosine similarity between the query and all movie descriptions
    similarity_scores = cosine_similarity(query_vector, tfidf_matrix).flatten()

    # Get indices of the top N similar movies
    top_indices = similarity_scores.argsort()[-top_n:][::-1]

    # Retrieve movie names and their similarity scores (rounded for neatness)
    recommendations = [
        (df.iloc[i]["movie_name"], round(similarity_scores[i], 3)) for i in top_indices
    ]
    return recommendations

# --- Streamlit App Layout ---

st.title("Movie Recommender System")
st.write("Enter a movie type/genre you like, and we'll recommend similar movies!")

# Load data and TF-IDF resources (cached for performance)
df = load_data()
tfidf_vectorizer, tfidf_matrix = get_tfidf_resources(df)

# User input: A text area for entering the movie description
user_query = st.text_area("Type your movie genre:")

# Button to trigger recommendation
if st.button("Get Recommendations"):
    if user_query:
        # Get recommendations based on the user's query
        recommendations = recommend_movies(user_query, tfidf_vectorizer, tfidf_matrix, df)

        # Ensure recommendations are in DataFrame format
        if isinstance(recommendations, list):
            recommendations = pd.DataFrame(recommendations, columns=["Top 5 Movie Recommendations", "Similarity Score"])

        st.write("### Top Recommendations:")
        st.table(recommendations)
    else:
        st.error("Please enter a valid movie description query!")